# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'basicform.ui'
#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import QGraphicsScene, QGraphicsView, QSplashScreen, QApplication, QGridLayout, QMainWindow, QGraphicsTextItem
from PyQt5.QtGui import QPixmap, QTransform, QFont, QFontDatabase
from PyQt5.QtCore import Qt
import time

import pyqtgraph.opengl as gl
import meshio

import numpy as np

from wpcsys import pywpc


DATA_PATH = "Material/viz_data/"
IMG_PATH = 'Material/viz_data/avion_'
tag = 'cat'

style_neon = DATA_PATH + "themeWPC.qss"   
text_properties = {
            'yaw': {'text': 'C', 'font': QtGui.QFont("Arial", 38), 'color': QtGui.QColor(232, 232, 232)},
            'pitch': {'text': 'P', 'font': QtGui.QFont("Arial", 38), 'color': QtGui.QColor(232, 232, 232)},
            'roll': {'text': 'W', 'font': QtGui.QFont("Arial", 38), 'color': QtGui.QColor(232, 232, 232)}
        }



DEGREE_TO_RADIAN   = np.pi / 180.0
RADIAN_TO_DEGREE   = 180.0 / np.pi





class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        self.graphicsView = QGraphicsView()
        self.dev = pywpc.WifiDAQE3A()
        ## DISPLAY
        
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(476, 384)
        MainWindow.setAutoFillBackground(False)
        MainWindow.showFullScreen()
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        
        self.MainVlayout = QtWidgets.QVBoxLayout(self.centralwidget)
        self.MainVlayout.setObjectName("MainVlayout")
        
        #Input Display
        self.InputLayout = QtWidgets.QHBoxLayout()
        self.InputLayout.setObjectName("InputLayout")
        self.lineEditIP = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEditIP.setMaximumWidth(300)  # Largeur maximale de 150 pixels
        self.lineEditIP.setObjectName("lineEditIP")
        self.lineEditIP.setText("192.168.5.39")
        self.InputLayout.addWidget(self.lineEditIP)
        
        self.comboBox_port = QtWidgets.QComboBox(self.centralwidget)
        self.comboBox_port.addItem("0")
        self.comboBox_port.setCurrentIndex(0)
        self.comboBox_port.setObjectName("comboBox_port")     
        self.InputLayout.addWidget(self.comboBox_port)
        
        self.pushConnect = QtWidgets.QPushButton(self.centralwidget)
        self.pushConnect.setObjectName("pushConnect")
        self.InputLayout.addWidget(self.pushConnect)
        self.pushConnect.clicked.connect(self.start_connection)
        
        self.pushStop = QtWidgets.QPushButton(self.centralwidget)
        self.pushStop.setObjectName("pushStop")
        self.InputLayout.addWidget(self.pushStop)
        self.pushStop.clicked.connect(self.stop_connection)
        
        self.pushQuit = QtWidgets.QPushButton(self.centralwidget)
        self.pushQuit.setObjectName("pushQuit")
        self.InputLayout.addWidget(self.pushQuit)
        self.pushQuit.clicked.connect(self.close_and_quit)
        self.lineEditIP.setAlignment(QtCore.Qt.AlignCenter)

      
        self.MainVlayout.addLayout(self.InputLayout)
        
        self.gridLayout = QtWidgets.QGridLayout()
        self.gridLayout.setObjectName("gridLayout")

        self.splitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal)  

        self.widget3D = QtWidgets.QGraphicsView(self.centralwidget)
        self.widget3D.setObjectName("graphicMesh")
        self.meshLayout = QtWidgets.QGridLayout()
        self.widget3D.setLayout(self.meshLayout)
        self.splitter.addWidget(self.widget3D)
        
        # Create a widget to hold the remaining widgets
        self.other_widgets = QtWidgets.QWidget()
        self.other_widgets_layout = QtWidgets.QGridLayout()
                
        self.graphicPitch = QtWidgets.QGraphicsView(self.centralwidget)
        self.graphicPitch.setObjectName("graphicPitch")
        self.other_widgets_layout.addWidget(self.graphicPitch, 2, 1, 1, 1)
        
        self.graphicYaw = QtWidgets.QGraphicsView(self.centralwidget)
        self.graphicYaw.setObjectName("graphicYaw")
        self.other_widgets_layout.addWidget(self.graphicYaw, 3, 1, 1, 1)
        
        self.graphicRoll = QtWidgets.QGraphicsView(self.centralwidget)
        self.graphicRoll.setObjectName("graphicRoll")
        self.other_widgets_layout.addWidget(self.graphicRoll, 1, 1, 1, 1)
        
        self.graphicPlanes = {'yaw': self.graphicYaw, 'pitch': self.graphicPitch, 'roll': self.graphicRoll}
        
        self.graphicTextPitch = QtWidgets.QGraphicsView(self.centralwidget)
        self.graphicTextPitch.setObjectName("graphicTextPitch")
        self.other_widgets_layout.addWidget(self.graphicTextPitch, 2, 2, 1, 1)
        
        self.graphicTextYaw = QtWidgets.QGraphicsView(self.centralwidget)
        self.graphicTextYaw.setObjectName("graphicTextYaw")
        self.other_widgets_layout.addWidget(self.graphicTextYaw, 3, 2, 1, 1)
        
        self.graphicTextRoll = QtWidgets.QGraphicsView(self.centralwidget)
        self.graphicTextRoll.setObjectName("graphicTextRoll")
        self.other_widgets_layout.addWidget(self.graphicTextRoll, 1, 2, 1, 1)
        
        self.other_widgets.setLayout(self.other_widgets_layout)

        self.splitter.addWidget(self.other_widgets)
        self.gridLayout.addWidget(self.splitter, 1, 1, 3, 1)
        
        
        
        
        
        self.MainVlayout.addLayout(self.gridLayout)
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 476, 22))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)
        
        #Input get infos
        
        self.ip_address = self.lineEditIP.text()
        self.port = int(self.comboBox_port.currentIndex())
        self.read_delay = 0.5 ## second
        self.timeout = 3 ## second
        self.sampling_period = 0.003
        
        self.timer_running = False #become True when start is pressed, to avoid multiple pressing errors
        self.quit_state = False
        ##Text Part 
        
        self.textSceneYaw = QGraphicsScene()
        self.textScenePitch = QGraphicsScene()
        self.textSceneRoll = QGraphicsScene()
        
 

        self.textItems = {}
        for key, props in text_properties.items():
            text_item = QtWidgets.QGraphicsTextItem(props['text'])
            text_item.setFont(props['font'])
            text_item.setDefaultTextColor(props['color'])
            self.textItems[key] = text_item

        # add texts to graphic scenes
        for key, text_item in self.textItems.items():
            scene = getattr(self, f"textScene{key.capitalize()}")
            scene.addItem(text_item)

        # define graphic scenes in a dictionary for an easy access
        
        
        self.graphicTextScenes = {
            'yaw': self.textSceneYaw,
            'pitch': self.textScenePitch,
            'roll': self.textSceneRoll
        }

        for key, scene in self.graphicTextScenes.items():
            graphic_text_widget = getattr(self, f"graphicText{key.capitalize()}")
            graphic_text_widget.setScene(scene)

        ## Plane Part 
        self.sceneYaw = QGraphicsScene()
        self.scenePitch = QGraphicsScene()
        self.sceneRoll = QGraphicsScene()
        
        self.graphicYaw.setScene(self.sceneYaw)
        self.graphicPitch.setScene(self.scenePitch)
        self.graphicRoll.setScene(self.sceneRoll)

        self.scene_dict = {'yaw' : self.sceneYaw, 'pitch' : self.scenePitch, 'roll' : self.sceneRoll}
        

        # Load and show images in their scenes
        self.load_image(f'{IMG_PATH}yaw.png', self.sceneYaw)
        self.load_image(f'{IMG_PATH}pitch.png', self.scenePitch)
        self.load_image(f'{IMG_PATH}roll.png', self.sceneRoll)
        
        
        self.pixmap_Yaw = self.sceneYaw.items()[0]
        self.Yaw_width = self.pixmap_Yaw.pixmap().width()
        self.Yaw_height = self.pixmap_Yaw.pixmap().height()
        self.Yaw_center = (self.Yaw_width / 2, self.Yaw_height / 2)
        
        self.pixmap_Pitch = self.scenePitch.items()[0]  
        self.Pitch_width = self.pixmap_Pitch.pixmap().width()
        self.Pitch_height = self.pixmap_Pitch.pixmap().height()
        self.Pitch_center = (self.Pitch_width / 2, self.Pitch_height / 2)
        
        self.pixmap_Roll = self.sceneRoll.items()[0]  
        self.Roll_width = self.pixmap_Roll.pixmap().width()
        self.Roll_height = self.pixmap_Roll.pixmap().height()
        self.Roll_center = (self.Roll_width / 2, self.Roll_height / 2)
        
        self.pixmap = {'yaw' : self.pixmap_Yaw, 'pitch' : self.pixmap_Pitch, 'roll' : self.pixmap_Roll} #dictionnary to store the pixmap
        self.center = {'yaw' : self.Yaw_center, 'pitch' : self.Pitch_center, 'roll' : self.Roll_center} #dictionnary to store the center of the pixmap

        #initialize useful constants
        self.dict_map = {'roll' : 0, 'pitch' : 1, 'yaw' : 2}
        
        #to prevent error in case of missing values, we just read the last one available
        self.list_angle = [[0,0] for i in range(3)]        
        
        ## Mesh Part
        
        # Create a widget to display 3D graphics
        self.widget3D = gl.GLViewWidget()

        # Load STL mesh file
        mesh = meshio.read(f'{DATA_PATH}{tag}.stl')
        
        # Extract vertices and faces
        
        self.vertices = mesh.points
        self.faces = mesh.cells[0].data

        # Create a mesh item
        self.mesh_item = gl.GLMeshItem(vertexes=self.vertices, faces=self.faces,  smooth=False, color=(152, 171, 238, 0.3))
        self.widget3D.addItem(self.mesh_item)
        # Set camera position and orientation
        # Calculate the maximum dimension of the mesh
        max_dimension = max(max(self.vertices[:, 0]) - min(self.vertices[:, 0]),
                    max(self.vertices[:, 1]) - min(self.vertices[:, 1]),
                    max(self.vertices[:, 2]) - min(self.vertices[:, 2]))

        # Set the camera distance based on the maximum dimension
        camera_distance = max_dimension * 1.2

        self.widget3D.setCameraPosition(distance=camera_distance)
        
        #change displaying
        self.mesh_item.setGLOptions('additive')
        self.mesh_item.setMeshData(vertexes=self.vertices, faces=self.faces, smooth=True, color=(152, 171, 238, 0.4))
        #plot a grid
        grid = gl.GLGridItem()
        self.widget3D.addItem(grid)

        grid.scale(max_dimension, max_dimension, max_dimension)
        grid.translate(0, 0, -max_dimension * 1.2)
        #light blue background, set it 
        self.widget3D.setBackgroundColor(5, 9, 27)
        
        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)
        








    def start_connection(self):
            if not self.timer_running:
                print(f'{pywpc.PKG_FULL_NAME} - Version {pywpc.__version__}')
                self.timer_running = True
                self.ip_address = self.lineEditIP.text()
                self.port = int(self.comboBox_port.currentIndex())
                try:
                     self.dev.connect("192.168.5.39") ## Depend on your device
                except Exception as err:
                    pywpc.printGenericError(err)
                    text_error = QtWidgets.QGraphicsTextItem('Error: ' + str(err))  
                    text_error.setDefaultTextColor(QtGui.QColor(255, 0, 0))  
                    self.textScenePitch.addItem(text_error)   
                    
                    ## Release device handle
                    self.dev.close()
                    return
                self.dev.AHRS_open(self.port, self.timeout)
                self.dev.AHRS_setSamplingPeriod(self.port, self.sampling_period, self.timeout)
                self.dev.AHRS_start(self.port, self.timeout)
                self.timer = QtCore.QTimer()
                self.timer.setInterval(50) # 10 ms
                self.timer.timeout.connect(self.general_update)
                self.timer.start()
    
    def stop_connection(self):
        if not self.timer_running and not self.quit_state:
             # Timer does not exist
            print("System not connected, can not stop.")
        
        elif not self.timer_running and self.quit_state:
            pass
            
        else:
            # Timer does exist
            self.timer.stop()
            self.timer_running = False

            ## Stop AHRS
            self.dev.AHRS_stop(self.port, self.timeout)

            ## Close AHRS
            self.dev.AHRS_close(self.port, self.timeout)
            print(f"AHRS_close in port {self.port}")

            ## Disconnect device
            self.dev.disconnect()    
            

    def close_and_quit(self):
        self.quit_state = True
        MainWindow.close() 
        self.stop_connection()
                
    def load_image(self, file_path, scene):
        pixmap = QPixmap(file_path)
        scene.addPixmap(pixmap)

    def general_update(self):
        self.ahrs_list = self.dev.AHRS_readStreaming(self.port, self.read_delay)
        self.ip_address = self.lineEditIP.text()  # New IP address
        
        # Get port from GUI
        self.port = int(self.comboBox_port.currentIndex())
        
        #in case of missing values, we just read the last one available
        for type in self.dict_map.keys():
            self.list_angle[self.dict_map.get(type)] = self.list_angle[self.dict_map.get(type)][1:]
            if len(self.ahrs_list) > 0:
                angle = self.ahrs_list[self.dict_map.get(type)]
            else:
                angle = self.list_angle[self.dict_map.get(type)][-1]
                
            self.ahrs_list[self.dict_map.get(type)] = angle 
             
        self.update_image_rotation_plane('yaw')
        self.update_image_rotation_plane('pitch')
        self.update_image_rotation_plane('roll')
        self.update_text()
        self.update_mesh()

    def align_texts(self, txt1, txt2, type):
        if len(txt1)>len(txt2):
            margin = (len(txt1)-len(txt2))//2
            self.textItems.get(type).setPlainText(txt1+'\n'+' '*margin+txt2)
        else:
            margin = (len(txt2)-len(txt1))//2
            self.textItems.get(type).setPlainText(' '*margin+txt1+'\n'+txt2)

    def update_text(self):
        
        #improvement : create a security process to avoid missing value (same as in update_image_rotation_plane)
        self.align_texts('Yaw', f'{self.ahrs_list[self.dict_map.get("yaw")]:.2f} deg', type='yaw')
        self.align_texts('Pitch', f'{self.ahrs_list[self.dict_map.get("pitch")]:.2f} deg', type='pitch')
        self.align_texts('Roll', f'{self.ahrs_list[self.dict_map.get("roll")]:.2f} deg', type='roll')
        

            
    def get_scene_dimensions(self, scene):
        scene_x = scene.sceneRect().width()
        scene_y = scene.sceneRect().height()
        return scene_x, scene_y
        
    def update_image_rotation_plane(self, type):
        # Appliquer la rotation Ã  l'image
 
        
            # Scale the pixmap
        angle = self.ahrs_list[self.dict_map.get(type)]
        self.graphicPlanes.get(type).fitInView(self.scene_dict.get(type).sceneRect(), Qt.KeepAspectRatio)     
        #calcul center of image  
        # Create a transformation for rotation
        transform = QTransform().translate(self.center.get(type)[0], self.center.get(type)[1]).rotate(angle).translate(-self.center.get(type)[0], -self.center.get(type)[1])
        
        # Apply the transformation to the pixmap
        self.pixmap.get(type).setTransform(transform)
        

    def WPC_getRotMat(self, use_deg=True):
        yaw, pitch, roll = self.ahrs_list[self.dict_map.get('yaw')], self.ahrs_list[self.dict_map.get('pitch')], self.ahrs_list[self.dict_map.get('roll')]
        if use_deg:
            roll *= DEGREE_TO_RADIAN
            pitch *= DEGREE_TO_RADIAN
            yaw *= DEGREE_TO_RADIAN
        rot_mat_x = np.array([[1, 0, 0], [0, np.cos(roll), np.sin(roll)], [0, -np.sin(roll), np.cos(roll)]])
        rot_mat_y = np.array([[np.cos(pitch), 0, np.sin(pitch)], [0, 1, 0], [-np.sin(pitch), 0, np.cos(pitch)]])
        rot_mat_z = np.array([[np.cos(yaw), -np.sin(yaw), 0], [np.sin(yaw), np.cos(yaw), 0], [0, 0, 1]])
        rot_mat = rot_mat_x.dot(rot_mat_y).dot(rot_mat_z) ## Dot product from the back RxRyRz
        return rot_mat    
        

    def update_mesh(self):
        self.ahrs_list = self.dev.AHRS_readStreaming(self.port, self.read_delay)
        # Apply rotation to vertices
        rotated_vertices = np.dot(self.vertices, self.WPC_getRotMat().T)

        # Update mesh with rotated vertices
        self.mesh_item.setMeshData(vertexes=rotated_vertices, faces=self.faces, smooth=True, color=(152, 171, 238, 0.4))
        # Add the widget to the layout
        self.meshLayout.removeWidget(self.widget3D)
        # Add the widget to the layout
        self.meshLayout.addWidget(self.widget3D, 0, 0, self.meshLayout.rowCount(), 1)
        

        
    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "WPC Visualisation"))
        self.pushConnect.setText(_translate("MainWindow", "Start and Connect"))
        self.pushStop.setText(_translate("MainWindow", "Stop"))
        self.pushQuit.setText(_translate("MainWindow", "Quit"))
        self.comboBox_port.setItemText(0, _translate("MainWindow", "Port 0"))

if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    
    splash_pix = QPixmap(DATA_PATH + 'WPClogo.jpg')
    splash_pix = splash_pix.scaledToWidth(400)  
    splash = QSplashScreen(splash_pix, Qt.WindowStaysOnTopHint)
    splash.setMask(splash_pix.mask())
    splash.show()
    
    
    time.sleep(2)  
    
    splash.finish(None)
    
    app.setStyleSheet(open(style_neon).read())
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())