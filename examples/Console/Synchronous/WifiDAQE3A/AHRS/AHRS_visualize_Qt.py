# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'basicform.ui'
#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import QGraphicsScene, QGraphicsView, QSplashScreen, QApplication, QGridLayout, QMainWindow, QGraphicsTextItem
from PyQt5.QtGui import QPixmap, QTransform, QFont, QFontDatabase
from PyQt5.QtCore import Qt
import time

import pyqtgraph.opengl as gl
import meshio

import numpy as np

from wpcsys import pywpc


DATA_PATH = "examples/Console/Synchronous/WifiDAQE3A/AHRS/data/"
IMG_PATH = 'examples/Console/Synchronous/WifiDAQE3A/AHRS/data/avion_'
tag = 'rat'

style_neon = DATA_PATH + "themeWPC.qss"   
text_properties = {
            'yaw': {'text': 'W', 'font': QtGui.QFont("Arial", 38), 'color': QtGui.QColor(232, 232, 232)},
            'pitch': {'text': 'P', 'font': QtGui.QFont("Arial", 38), 'color': QtGui.QColor(232, 232, 232)},
            'roll': {'text': 'C', 'font': QtGui.QFont("Arial", 38), 'color': QtGui.QColor(232, 232, 232)}
        }



DEGREE_TO_RADIAN   = np.pi / 180.0
RADIAN_TO_DEGREE   = 180.0 / np.pi





class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        self.graphicsView = QGraphicsView()
        
        ## DISPLAY
        
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(476, 384)
        MainWindow.setAutoFillBackground(False)
        MainWindow.showFullScreen()
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        
        self.MainVlayout = QtWidgets.QVBoxLayout(self.centralwidget)
        self.MainVlayout.setObjectName("MainVlayout")
        
        #Input Display
        self.InputLayout = QtWidgets.QHBoxLayout()
        self.InputLayout.setObjectName("InputLayout")
        self.lineEditIP = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEditIP.setMaximumWidth(300)  # Largeur maximale de 150 pixels
        self.lineEditIP.setObjectName("lineEditIP")
        self.lineEditIP.setText("192.168.5.39")
        self.InputLayout.addWidget(self.lineEditIP)
        self.pushConnect = QtWidgets.QPushButton(self.centralwidget)
        self.pushConnect.setStyleSheet(style_neon)
        self.pushConnect.setObjectName("pushConnect")
        self.InputLayout.addWidget(self.pushConnect)
        self.pushConnect.clicked.connect(self.start_connection)
        
        self.pushStop = QtWidgets.QPushButton(self.centralwidget)
        self.pushStop.setObjectName("pushStop")
        self.InputLayout.addWidget(self.pushStop)
        self.pushStop.clicked.connect(self.stop_connection)
        
        self.pushQuit = QtWidgets.QPushButton(self.centralwidget)
        self.pushQuit.setObjectName("pushQuit")
        self.InputLayout.addWidget(self.pushQuit)
        self.pushQuit.clicked.connect(self.close_and_quit)
        self.lineEditIP.setAlignment(QtCore.Qt.AlignCenter)

        
        self.comboBox_port = QtWidgets.QComboBox(self.centralwidget)
        self.comboBox_port.addItem("0")
        self.comboBox_port.setCurrentIndex(0)
        self.comboBox_port.setObjectName("comboBox_port")
        

        
        self.InputLayout.addWidget(self.comboBox_port)
      
        self.MainVlayout.addLayout(self.InputLayout)
        
        self.gridLayout = QtWidgets.QGridLayout()
        self.gridLayout.setObjectName("gridLayout")

        self.splitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal)  

        self.widget3D = QtWidgets.QGraphicsView(self.centralwidget)
        self.widget3D.setObjectName("graphicMesh")
        self.meshLayout = QtWidgets.QGridLayout()
        self.widget3D.setLayout(self.meshLayout)
        self.splitter.addWidget(self.widget3D)
        
        # Create a widget to hold the remaining widgets
        self.other_widgets = QtWidgets.QWidget()
        self.other_widgets_layout = QtWidgets.QGridLayout()
                
        self.graphicPitch = QtWidgets.QGraphicsView(self.centralwidget)
        self.graphicPitch.setObjectName("graphicPitch")
        self.other_widgets_layout.addWidget(self.graphicPitch, 2, 1, 1, 1)
        
        self.graphicYaw = QtWidgets.QGraphicsView(self.centralwidget)
        self.graphicYaw.setObjectName("graphicYaw")
        self.other_widgets_layout.addWidget(self.graphicYaw, 1, 1, 1, 1)
        
        self.graphicRoll = QtWidgets.QGraphicsView(self.centralwidget)
        self.graphicRoll.setObjectName("graphicRoll")
        self.other_widgets_layout.addWidget(self.graphicRoll, 3, 1, 1, 1)
        
        self.graphicTextPitch = QtWidgets.QGraphicsView(self.centralwidget)
        self.graphicTextPitch.setObjectName("graphicTextPitch")
        self.other_widgets_layout.addWidget(self.graphicTextPitch, 2, 2, 1, 1)
        
        self.graphicTextYaw = QtWidgets.QGraphicsView(self.centralwidget)
        self.graphicTextYaw.setObjectName("graphicTextYaw")
        self.other_widgets_layout.addWidget(self.graphicTextYaw, 1, 2, 1, 1)
        
        self.graphicTextRoll = QtWidgets.QGraphicsView(self.centralwidget)
        self.graphicTextRoll.setObjectName("graphicTextRoll")
        self.other_widgets_layout.addWidget(self.graphicTextRoll, 3, 2, 1, 1)
        
        self.other_widgets.setLayout(self.other_widgets_layout)

        self.splitter.addWidget(self.other_widgets)
        self.gridLayout.addWidget(self.splitter, 1, 1, 3, 1)
        
        
        
        
        self.MainVlayout.addLayout(self.gridLayout)
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 476, 22))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)
        
        #Input get infos
        
        self.ip_address = self.lineEditIP.text()
        self.port = int(self.comboBox_port.currentIndex())
        self.read_delay = 0.5 ## second
        self.timeout = 3 ## second
        self.sampling_period = 0.003

        ##Tewt Part 
        
        self.textSceneYaw = QGraphicsScene()
        self.textScenePitch = QGraphicsScene()
        self.textSceneRoll = QGraphicsScene()
        
        

        self.textItems = {}
        for key, props in text_properties.items():
            text_item = QtWidgets.QGraphicsTextItem(props['text'])
            text_item.setFont(props['font'])
            text_item.setDefaultTextColor(props['color'])
            self.textItems[key] = text_item

        # add texts to graphic scenes
        for key, text_item in self.textItems.items():
            scene = getattr(self, f"textScene{key.capitalize()}")
            scene.addItem(text_item)

        # define graphic scenes in a dictionary for an easy access
        self.graphicTextScenes = {
            'yaw': self.textSceneYaw,
            'pitch': self.textScenePitch,
            'roll': self.textSceneRoll
        }

        for key, scene in self.graphicTextScenes.items():
            graphic_text_widget = getattr(self, f"graphicText{key.capitalize()}")
            graphic_text_widget.setScene(scene)

        ## Plane Part 
        self.sceneYaw = QGraphicsScene()
        self.scenePitch = QGraphicsScene()
        self.sceneRoll = QGraphicsScene()
        
        self.graphicYaw.setScene(self.sceneYaw)
        self.graphicPitch.setScene(self.scenePitch)
        self.graphicRoll.setScene(self.sceneRoll)

        self.scene_dict = {'yaw' : self.sceneYaw,'pitch' : self.scenePitch,'roll' : self.sceneRoll}
        

        # Load and show images in their scenes
        self.load_image(f'{IMG_PATH}yaw.png', self.sceneYaw)
        self.load_image(f'{IMG_PATH}pitch.png', self.scenePitch)
        self.load_image(f'{IMG_PATH}roll.png', self.sceneRoll)
        
        
        #a revoir !!!!!!!!!!!!!!!!!!!!!
        self.pixmap_Yaw = self.sceneYaw.items()[0]  
        self.Yaw_width = self.pixmap_Yaw.pixmap().width()
        self.Yaw_height = self.pixmap_Yaw.pixmap().height()
        self.Yaw_center = (self.Yaw_width / 2, self.Yaw_height / 2)
        
        self.pixmap_Pitch = self.scenePitch.items()[0]  
        self.Pitch_width = self.pixmap_Pitch.pixmap().width()
        self.Pitch_height = self.pixmap_Pitch.pixmap().height()
        self.Pitch_center = (self.Pitch_width / 2, self.Pitch_height / 2)
        
        self.pixmap_Roll = self.sceneRoll.items()[0]  
        self.Roll_width = self.pixmap_Roll.pixmap().width()
        self.Roll_height = self.pixmap_Roll.pixmap().height()
        self.Roll_center = (self.Roll_width / 2, self.Roll_height / 2)
        
        self.pixmap = {'yaw' : self.pixmap_Yaw,'pitch' : self.pixmap_Pitch,'roll' : self.pixmap_Roll} #dictionnary to store the pixmap
        self.center = {'yaw' : self.Yaw_center,'pitch' : self.Pitch_center,'roll' : self.Roll_center} #dictionnary to store the center of the pixmap

        #initialize useful constants
        self.dict_map = {'yaw' : 0,'pitch' : 1,'roll' : 2}
        
        #to prevent error in case of missing values, we just read the last one available
        self.list_angle = [[0,0] for i in range(3)]        
        
        ## Mesh Part
        
        # Create a widget to display 3D graphics
        self.widget3D = gl.GLViewWidget()

        # Load STL mesh file
        mesh = meshio.read(f'{DATA_PATH}{tag}.stl')
        
        # Extract vertices and faces
        
        self.vertices = mesh.points
        self.faces = mesh.cells[0].data

        # Create a mesh item
        self.mesh_item = gl.GLMeshItem(vertexes=self.vertices, faces=self.faces, smooth=False, color=(152, 171, 238,0.3))
        self.widget3D.addItem(self.mesh_item)
        # Set camera position and orientation
        self.widget3D.setCameraPosition(distance=120)
        
        #change displaying
        self.mesh_item.setGLOptions('additive')
        self.mesh_item.setMeshData(vertexes=self.vertices, faces=self.faces, smooth=True, color=(152, 171, 238,0.4))
        #plot a grid
        grid = gl.GLGridItem()
        self.widget3D.addItem(grid)
        grid.scale(10, 10, 10)
        grid.translate(0, 0, -12)
        #light blue background, set it 
        self.widget3D.setBackgroundColor(5,9,27)
        
        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)
        








    def start_connection(self):
        # Add a timer to simulate new temperature measurements
        self.ip_address = self.lineEditIP.text()
        self.port = int(self.comboBox_port.currentIndex())
        self.dev = pywpc.WifiDAQE3A()
        self.dev.connect(self.ip_address)
        self.dev.AHRS_open(self.port,self.timeout)
        self.dev.AHRS_setSamplingPeriod(self.port, self.sampling_period, self.timeout)
        self.dev.AHRS_start(self.port, self.timeout)
        self.timer = QtCore.QTimer()
        self.timer.setInterval(50) # 10 ms
        self.timer.timeout.connect(self.general_update)
        self.timer.start()
    
    def stop_connection(self):
        try:
            getattr(self, "timer")
            self.timer.stop()
            self.dev.AI_stop(self.port)
            # Le timer existe
        except AttributeError:
        # Le timer n'existe pas
            print("It's complicated to stop, when it's not started :)")

    def close_and_quit(self):
        MainWindow.close()
        quit()
        
               
    def load_image(self, file_path, scene):
        pixmap = QPixmap(file_path)
        scene.addPixmap(pixmap)

    def general_update(self):
        self.ahrs_list = self.dev.AHRS_readStreaming(self.port,self.read_delay)
        self.ip_address = self.lineEditIP.text()  # Récupérer la nouvelle adresse IP saisie par l'utilisateur
        # Get port from GUI
        self.port = int(self.comboBox_port.currentIndex())
        
        self.update_image_rotation_plane('yaw')
        self.update_image_rotation_plane('pitch')
        self.update_image_rotation_plane('roll')
        self.update_text()
        self.update_mesh()

    def align_texts(self, txt1,txt2,type):
        if len(txt1)>len(txt2):
            margin = (len(txt1)-len(txt2))//2
            self.textItems.get(type).setPlainText(txt1+'\n'+' '*margin+txt2)
        else:
            margin = (len(txt2)-len(txt1))//2
            self.textItems.get(type).setPlainText(' '*margin+txt1+'\n'+txt2)

    def update_text(self):
        
        #improvement : create a security process to avoid missing value (same as in update_image_rotation_plane)
        self.align_texts('Yaw',f'{self.ahrs_list[self.dict_map.get("yaw")]:.2f}',type='yaw')
        self.align_texts('Pitch',f'{self.ahrs_list[self.dict_map.get("pitch")]:.2f}',type='pitch')
        self.align_texts('Roll',f'{self.ahrs_list[self.dict_map.get("roll")]:.2f}',type='roll')
        

            
    def get_scene_dimensions(self,scene):
        scene_x = scene.sceneRect().width()
        scene_y = scene.sceneRect().height()
        return scene_x, scene_y
        
    def update_image_rotation_plane(self,type):
        # Appliquer la rotation à l'image
        self.list_angle[self.dict_map.get(type)] = self.list_angle[self.dict_map.get(type)][1:]
        if len(self.ahrs_list) > 0:
            angle = self.ahrs_list[self.dict_map.get(type)]
        else:
            angle = self.list_angle[self.dict_map.get(type)][-1]
            
        self.list_angle[self.dict_map.get(type)].append(angle)
        
            # Scale the pixmap
        scene_x, scene_y = self.get_scene_dimensions(self.scene_dict.get(type))
        min_scene = min(scene_x, scene_y)
        pixmap_item = self.pixmap.get(type)
        original_pixmap = pixmap_item.pixmap()
        scaled_pixmap = original_pixmap.scaledToWidth(300)
        
        #calcul center of image 
        scaled_width = scaled_pixmap.width()
        scaled_height = scaled_pixmap.height()
        scaled_center = (scaled_width / 2, scaled_height / 2)        
        # Create a transformation for rotation
        transform = QTransform().translate(scaled_center[0], scaled_center[1]).rotate(angle).translate(-scaled_center[0], -scaled_center[1])
        
        # Apply the transformation to the pixmap
        pixmap_item.setPixmap(scaled_pixmap)
        pixmap_item.setTransform(transform)
        
        # Center image 
        scene_rect = pixmap_item.sceneBoundingRect()
        scene_width = pixmap_item.scene().width()
        scene_height = pixmap_item.scene().height()
        dx = (scene_width - scene_rect.width()) / 2 - scene_rect.x() # coordonnées du coin supérieur gauche
        dy = (scene_height - scene_rect.height()) / 2 - scene_rect.y() #coordonnées du coin inférieur droit  pas sur à revoir !!!!!
        pixmap_item.setPos(pixmap_item.x() + dx, pixmap_item.y() + dy)
    def WPC_getRotMat(self, use_deg=True):
        yaw, pitch, roll = self.ahrs_list[self.dict_map.get('yaw')], self.ahrs_list[self.dict_map.get('pitch')], self.ahrs_list[self.dict_map.get('roll')]
        if use_deg:
            roll *= DEGREE_TO_RADIAN
            pitch *= DEGREE_TO_RADIAN
            yaw *= DEGREE_TO_RADIAN
        rot_mat_x = np.array([[1, 0, 0], [0, np.cos(roll), np.sin(roll)], [0, -np.sin(roll), np.cos(roll)]])
        rot_mat_y = np.array([[np.cos(pitch), 0, np.sin(pitch)], [0, 1, 0], [-np.sin(pitch), 0, np.cos(pitch)]])
        rot_mat_z = np.array([[np.cos(yaw), -np.sin(yaw), 0], [np.sin(yaw), np.cos(yaw), 0], [0, 0, 1]])
        rot_mat = rot_mat_x.dot(rot_mat_y).dot(rot_mat_z) ## Dot product from the back RxRyRz
        return rot_mat    
        

    def update_mesh(self):
        self.ahrs_list = self.dev.AHRS_readStreaming(self.port,self.read_delay)
        # Apply rotation to vertices
        rotated_vertices = np.dot(self.vertices, self.WPC_getRotMat().T)

        # Update mesh with rotated vertices
        self.mesh_item.setMeshData(vertexes=rotated_vertices, faces=self.faces, smooth=True, color=(152, 171, 238, 0.4))
        # Add the widget to the layout
        self.meshLayout.removeWidget(self.widget3D)
        # Add the widget to the layout
        self.meshLayout.addWidget(self.widget3D, 0, 0, self.meshLayout.rowCount(), 1)
        

        
    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "WPC Visualisation"))
        self.pushConnect.setText(_translate("MainWindow", "Start and Connect"))
        self.pushStop.setText(_translate("MainWindow", "Stop"))
        self.pushQuit.setText(_translate("MainWindow", "Quit"))
        self.comboBox_port.setItemText(0, _translate("MainWindow", "Port 0"))

if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    
    splash_pix = QPixmap(DATA_PATH + 'WPClogo.jpg')
    splash_pix = splash_pix.scaledToWidth(400)  
    splash = QSplashScreen(splash_pix, Qt.WindowStaysOnTopHint)
    splash.setMask(splash_pix.mask())
    splash.show()
    
    
    time.sleep(2)  
    
    splash.finish(None)
    
    app.setStyleSheet(open(style_neon).read())
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())